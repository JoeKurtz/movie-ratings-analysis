# -*- coding: utf-8 -*-
"""Final deliverables: Do Movie Ratings Increase or Decrease Throughout the Movie Series?

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oOLEOWzqP2NvOq8hRSRDuUQZ_DX9MiNl

### Joe Kurtz

## Declare which database you are going to use

Choose your database
"""

DB_NAME = "imdb"

"""Import libraries"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
# %config InlineBackend.figure_format = 'retina'

!sudo pip install geopandas > /dev/null
import pandas as pd
import matplotlib
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd

sns.set_style("whitegrid")
sns.set(rc={'figure.figsize': (10, 10)})
matplotlib.style.use(['seaborn-talk', 'seaborn-ticks'])

"""## Database Setup

Note: do NOT modify this part
"""

# download and initialize the psql proxy
!wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O cloud_sql_proxy
!chmod +x cloud_sql_proxy
# Downloading IAM service account key (database authentication key)
!wget "https://www.dropbox.com/s/n46vpzota59ctmr/ub23-2021-f2bd1ae1b18f.json?dl=0"
!mv "ub23-2021-f2bd1ae1b18f.json?dl=0" test.json
# Installing related libraries to Colab.
!sudo apt-get install python3-dev libmysqlclient-dev > /dev/null
!pip install mysqlclient > /dev/null
!sudo pip3 install -U sql_magic > /dev/null
#!sudo pip3 install ipython-sql

"""### Setting up the proxy. If you have "connection error" run the cell below again to fix the issue."""

!nohup ./cloud_sql_proxy -instances="ub23-2021:us-east1:ub23sql"=tcp:5432 -credential_file=test.json &
!sleep 5s

from sqlalchemy import create_engine

conn_string = 'mysql://{user}:{password}@{host}/{database}?charset=utf8'.format(
    host = '127.0.0.1:5432', 
    user = 'ub23sql',
    password = 'student',
    database = DB_NAME)

engine = create_engine(conn_string)
con = engine.connect()

"""### IF the connections is established. You will see texts like 

```
<sqlalchemy.engine.base.Connection object at 0x7f8242330780>
```


"""

# Commented out IPython magic to ensure Python compatibility.
# Prepare sql_magic library that enable to query to database easily.
# %reload_ext sql_magic
# %config SQL.conn_name = 'engine'

# Commented out IPython magic to ensure Python compatibility.
# # Note: we relax limit to 1M here. Change the sql_select_limit on your demand
# %%read_sql
# SET sql_safe_updates=1, sql_select_limit=1000000, max_join_size=10000000000;

# Commented out IPython magic to ensure Python compatibility.
# # Declare we are using the database.
# %%read_sql
# USE {DB_NAME};

"""# Rotten Tomatoes Database Setup"""

!wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O cloud_sql_proxy
!chmod +x cloud_sql_proxy
# Downloading IAM service account key (database authentication key)
!wget "https://www.dropbox.com/s/ya2vy72magtw2nw/rotten_tomatoes_movies.csv?dl=0"
!mv "rotten_tomatoes_movies.csv?dl=0" rotten_tomatoes_movies.csv
# Installing related libraries to Colab.
!sudo apt-get install python3-dev libmysqlclient-dev > /dev/null
!pip install mysqlclient > /dev/null
!sudo pip3 install -U sql_magic > /dev/null

rt_movies = pd.read_csv(
    "rotten_tomatoes_movies.csv",
    parse_dates=True,
    infer_datetime_format=True,
    low_memory=False)

"""# Summary

After being handed this assignment with the IMDB dataframe, we wondered to ourselves what exactly we were going to anaylyze. Each memeber of our group are self-identified movie fanatics, where one of our favorite hobbies is to sit back and watch a movie with some friends.

After discovering that each of us love to watch movies, we asked each other what movie was our individual favorites. Needless to say, this led to a ton of disagreement. A big factor on judging whose movie was better was rating the consistency of the movie - that is, how well did the sequel of the movie perform in our minds? Did it live up to the hype of the first one? Was the sequel a flop? 

While some of our favorite movies were solos movies (i.e. there was no sequel), most of our favorites were part of a series. To add to this, Hiram, a key member of team JHI, argued that sequels to a movie NEVER (in caps on purpose - he assetered this rather emphatically) live up to the first movie. I [Joe] had to argue to back on this - after all, the Harry Potter movies seemingly got better over time!

This led us to our question, our topic of interest, if you will, one that asked:
## ***How do Movie Ratings Fluctuate Throughout a Movie Series?***

We needed to put this argument to rest. Particularly, we wanted to know if in fact sequels and subsequent movies as part of a series actually performed worse, or if this was just misconception. 

Some Famous Movie Series' We Looked At:
1.   The Godfather
2.   The Matrix
3.   The Maze Runner
4.   Men in Black
5.   Lord of the Rings
6.   Spider-Man
7.   Back to the Future

Before I get into the finding, I believe it is impertive to list out some limitations we faced:

## ***Limitations***

*   *First off*, and most obvious, our sample of movies isn't exactly a random sample; Each movie series are among the more popular movie series' and hence the statistics would be a bit skewed. While we know this is true, we believe the general idea of our analysis still has validity, and the coding aspect is definitely strong.
*   *Second off*, for a real statistical sample, our data would have to be normal to perform these calculations. We acknowledge this, and also would like to note that a linear regression would be more telling too in analyzing the trends.
*   *Third off*, and lastly, our sample size is too small for a real analysis. However, like aforementioned, the coding aspect of our analysis is strong, even if real implications cannot be assumed.

## ***Analysis Process***

The Process of our analysis was as follows:

*IMDB*:


1.   Use SQL JOINs and different queries to collect the desired movies for analysis, seperated by the Movie Title and its Average Rating
2.   Each Movie was then assigned to a variable for plotting purposes
3.   Following the SQL queries for selecting our movies, we then plotted each movie with the x-axis being the movie number (plotted by index) and the y-axis being its average rating
4.   Looking at the data and the plots, we then analyzed the general trend of the movie ratings
5.   We then compiled each movie and its ratings into a dataframe, with the columns being the individual movie series and the rows being the movies ratings plotted by index
6.   With this dataframe, we took the mean of each index (i.e. the mean of all ratings of the first movies of the series, the seconnd movies,...) and plotted the results on a graph
7.   Looking at the data and the plots, we then analyzed the general trend of the movie ratings

*Rotten Tomato*:


1.   Use Pandas filtering to collect the desired movies for analysis, seperated by the Movie Title and its Average Rating
2.   We then plotted each movie with the x-axis being the movie number (plotted by index) and the y-axis being its Tomoto-Meter Score
3.   Looking at the data and the plots, we then analyzed the general trend of the movie ratings
4.   We then compiled each movie and its ratings into a dataframe, with the columns being the individual movie series and the rows being the movies tomato score plotted by index
5.   With this dataframe, we took the mean of each index (i.e. the mean of all scores of the first movies of the series, the seconnd movies,...) and plotted the results on a graph
6.   Looking at the data and the plots, we then analyzed the general trend of the movie ratings

Now, into the results of our analysis:

## ***Findings***

Looking at the *IMDB Data* first, we see the trend of movie ratings decreasing over time. Generally, for our sampled movie series, the first movie in the series was the highest rated movie in the series. Gradually, as subsequent movies within the same movie series were produced, the ratings decreased, never to recover to the first movie's ratings.

This trend holds true for 6/7 movies analyzed. The only outlier in this select sample was Lord of the Rings, where the second movie was the highest rated, while all three were both closely and highly rated.

Putting the analysis' limitations to the side, we were able to accept the null hypothesis that the ratings decrease as subsequent movies are produced.

Below is the agregated chart for all the movies and its average rating:
"""

df_imdb_movies

"""This observation is confirmed by the *Rotten Tomato* data. Similar to the IMDB ratings, as subsequent movies within the same movie series were produced, the ratings decreased, never to recover to the first movie's ratings.

While using IMDB's ratings 6/7 movies confirm that finding, simply looking at Rotten Tomato scores, only 4/7 movies follow that trend, while Spider-Man 2 rated higher than Spider-Man, and The Godfather II rated equally to The Godfather.

Putting the analysis' limitations to the side, we could not accept (or reject)the null hypothesis that the ratings decrease as subsequent movies are produced from the Rotten Tomato data as the data is inconclusive.

Below is the agregated chart for all the movies and its Rotten Tomato Score:
"""

df_rt_movies

"""Obviously, however, froma statistics standpoint, the data collected is not substantial enough to either accept or reject our null hypothesis that movie ratings decrease through out a movie series

## ***Contributions***

Now onto the more technical aspect of this summary: Each person's contribution. I would like to preface this that each person in team JHI put in a lot of effort and countless minutes into this project. 


*   *Joe*: IMDB analysis (aggregating data, SQL Joins, Plotting Data, Creating dataframes ... etc) & Rotten Tomato analysis (Pandas filtering, plotting, aggregation, Creating Dataframes, ... etc)
*   *Hiram*: IMDB analysis (aggregating data, SQL Joins, Plotting Data, Creating dataframes ... etc) & Rotten Tomato analysis (Pandas filtering, plotting, aggregation, Creating Dataframes, ... etc)

# Code Part

## IMDB "Random Sample" Trilogy's Ratings

### 7 Movie's SQL Joins's

Finding The Godfather ("tg") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst"
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql tg_movies_ratings -d
#  SELECT ep.tconst, ep.titleType, ep.primaryTitle, ep.originalTitle, ep.startYear, ep.runtimeMinutes, ep.genres, rat.averageRating as rating, rat.numVotes 
#   FROM TitleBasics ep
#   INNER JOIN TitleRatings rat ON ep.tconst = rat.tconst
#   WHERE originalTitle 
#   LIKE '%The Godfather%' 
#   AND titleType = 'movie'
#   AND runtimeMinutes >= 100
#   ORDER BY startYear ASC;

"""Finding Spider-Man ("sm") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst" ;

Note: This is the Tobey Maguire Spider-Man 
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql sm_movies_ratings -d
# SELECT primaryTitle, AverageRating
# FROM TitleBasics b
# INNER JOIN TitleRatings r ON r.tconst = b.tconst
# WHERE primarytitle in ("Spider-Man", "Spider-Man 2", "Spider-Man 3")
# AND titleType = "movie"
# AND runtimeMinutes >= 100
# ;

"""Finding The Matrix ("m") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst"
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql m_movies_ratings -d
# SELECT *
# FROM TitleBasics b
# INNER JOIN TitleRatings r ON r.tconst = b.tconst
# WHERE primarytitle like ("%Matrix%")
# AND titleType = "movie"
# AND genres = "Action,Sci-Fi"
# 
# ;

"""Finding Lord of the Rings ("lotr") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst" ;

Note: We are analyzing the 2000s version
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql lotr_movies_ratings -d
# SELECT primaryTitle, AverageRating
# FROM TitleBasics b
# INNER JOIN TitleRatings r ON r.tconst = b.tconst
# WHERE primarytitle like ("%Lord of the Rings%")
# AND titleType = "movie"
# AND runtimeMinutes >= 75
# AND genres like ("%adventure%")
# AND startYear >1978
# 
# ;

"""Finding Back to the Future ("bttf") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst" ;
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql bttf_movies_ratings -d
# SELECT primaryTitle, AverageRating
# FROM TitleBasics b
# INNER JOIN TitleRatings r ON r.tconst = b.tconst
# WHERE primarytitle like ("%Back to the Future%")
# AND titleType = "movie"
# AND runtimeMinutes >= 75
# AND genres like ("%adventure%")
# AND startYear > 1984 
# AND startYear < 2020
# ;

"""Finding Men in Black ("mib") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst" ;

Note: We are analyzing the Will Smith version
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql mib_movies_ratings -d
# SELECT primaryTitle, AverageRating
# FROM TitleBasics b
# INNER JOIN TitleRatings r ON r.tconst = b.tconst
# WHERE primarytitle like ("%Men in Black%")
# AND titleType = "movie"
# AND runtimeMinutes >= 75
# AND genres like ("%adventure%")
# AND startYear < 2019
# 
# ;

"""Finding Maze Runner ("mr") Movie Series from the IMDB database TitleBasics table ;

Inner Joining its Ratings From TitleRating Table using "tconst" ;
"""

# Commented out IPython magic to ensure Python compatibility.
# %%read_sql mr_movies_ratings  -d
# SELECT primaryTitle, AverageRating
# FROM TitleBasics b
# INNER JOIN TitleRatings r ON r.tconst = b.tconst
# WHERE primarytitle like ("%Maze Runner%")
# AND titleType = "movie"
# 
# ;

"""### Data Charts and Plots

Plotting out Each Aformentioned Movie's Average Rating

Note: Movies are plotted by index in order of release date (ex: The Godather = 0, The Godfather II = 1, ...etc)
"""

tg_movies_ratings["rating"].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = m_movies_ratings["averageRating"].index)

m_movies_ratings['averageRating'].plot(
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = m_movies_ratings["averageRating"].index
)

lotr_movies_ratings.plot(
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = lotr_movies_ratings.index
)

bttf_movies_ratings.plot(
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = bttf_movies_ratings.index
)

mib_movies_ratings.plot(
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = mib_movies_ratings.index
)

mr_movies_ratings.plot(
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = mr_movies_ratings.index
)

sm_movies_ratings.plot(
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = sm_movies_ratings.index
)

"""Compiling each movie's average rating into its own dataframe, with the columns being each movie, and the row being the average rating per index of movie (i.e. number of movie in the series - first, second, third)"""

df_imdb_movies = pd.DataFrame(data = { 'Maze Runner': mr_movies_ratings['AverageRating'], 
                     'Men In Black': mib_movies_ratings['AverageRating'],
                     'The Matrix': m_movies_ratings['averageRating'],
                     'Lord Of The Rings': lotr_movies_ratings['AverageRating'],
                     'The Godfather': tg_movies_ratings['rating'],
                     'Back To The Future': bttf_movies_ratings['AverageRating'],
                     'Spider-Man': sm_movies_ratings['AverageRating']

                     })

"""Calculating / Aggregating the Average Rating of All the movies by Index - the average rating of all the first movies, the second movies, and the third movies of each Movie Series

Plotting out the results
"""

mean_per_index = df_imdb_movies.mean(axis=1)
mean_per_index.plot(
    xlabel = "Movie Order",
    ylabel = "AVG Rating",
    xticks = mean_per_index.index
)

"""## Rotten tomatoes"""

# Changing Data Types
# Making "original_release_date" a datetime
rt_movies["original_release_date"] = pd.to_datetime(rt_movies["original_release_date"], format="%Y/%m/%d")
rt_movies.dtypes

"""### 7 Pandas Filtering by Movie"""

# Finding Spider-Man ("sm") Movies' Ratings from Rotten Tomaotoes
# Note: Only looking for Tobey Maguire ("tm") Version
# These Movies are Sorted Ascending by Release Date
all_spider_man = rt_movies["movie_title"].str.contains("Spider-Man")
df_all_sm = rt_movies[all_spider_man]
tm_sm_movies = df_all_sm["actors"].str.contains("Tobey Maguire")
df_tm_sm = df_all_sm[tm_sm_movies].sort_values("original_release_date")

df_tm_sm = df_tm_sm.reset_index()
del df_tm_sm['index']

df_tm_sm[["movie_title", "tomatometer_rating"]]

# Finding The Godfather ("tg") Movies' Ratings from Rotten Tomaotoes
# Note: Only looking for Al Pacino ("ap") Version
# These Movies are Sorted Ascending by Release Date
the_godfather = rt_movies["movie_title"].str.contains("The Godfather")
df_tg_movies = rt_movies[the_godfather]
ap_tg_movies = df_tg_movies["actors"].str.contains("Al Pacino")
df_ap_tg = df_tg_movies[ap_tg_movies].sort_values("original_release_date")

df_ap_tg = df_ap_tg.reset_index()
del df_ap_tg['index']


df_ap_tg[["movie_title", "tomatometer_rating"]]

# Finding Men In Black ("mib") Movies' Ratings from Rotten Tomaotoes
# Note: Only looking for Will Smith ("ws") Version
# These Movies are Sorted Ascending by Release Date
mib_movies = rt_movies["movie_title"].str.contains("Men in Black")
df_mib_movies = rt_movies[mib_movies]
ws_mib_movies = df_mib_movies["actors"].str.contains("Will Smith")
df_ws_mib = df_mib_movies[ws_mib_movies].sort_values("original_release_date")

df_ws_mib = df_ws_mib.reset_index()
del df_ws_mib['index']


df_ws_mib[["movie_title", "tomatometer_rating"]]

# Finding The Matrix ("tm") Movies' Ratings from Rotten Tomaotoes
# Note: Only looking for Lilly Wachowski ("lw") Directed Version
# These Movies are Sorted Ascending by Release Date
tm_movies = rt_movies["movie_title"].str.contains("The Matrix")
df_tm_movies = rt_movies[tm_movies]
lw_tm_movies = df_tm_movies["directors"].str.contains("Lilly Wachowski")
df_lw_tm = df_tm_movies[lw_tm_movies].sort_values("original_release_date")

df_lw_tm = df_lw_tm.reset_index()
del df_lw_tm['index']

df_lw_tm[["movie_title", "tomatometer_rating"]]

# Finding Lord of the Rings ("lotr") Movies' Ratings from Rotten Tomaotoes
# Note: Only looking for Elijah Wood ("ew") Version
# These Movies are Sorted Ascending by Release Date
lotr_movies = rt_movies["movie_title"].str.contains("Lord of the Rings")
df_lotr_movies = rt_movies[lotr_movies]
ew_lotr_movies = df_lotr_movies["actors"].str.contains("Elijah Wood")
df_ew_lotr = df_lotr_movies[ew_lotr_movies].sort_values("original_release_date")

df_ew_lotr = df_ew_lotr.reset_index()
del df_ew_lotr['index']

df_ew_lotr[["movie_title", "tomatometer_rating"]]

# Finding Back to the Future ("bttf") Movies' Ratings from Rotten Tomaotoes
# These Movies are Sorted Ascending by Release Date
bttf_movies = rt_movies["movie_title"].str.contains("Back to the Future")
df_bttf_movies = rt_movies[bttf_movies].sort_values("original_release_date")

df_bttf_movies = df_bttf_movies.reset_index()
del df_bttf_movies['index']

df_bttf_movies[["movie_title", "tomatometer_rating"]]

# Finding Maze Runner ("mr") Movies' Ratings from Rotten Tomaotoes
# These Movies are Sorted Ascending by Release Date
mr_movies = rt_movies["movie_title"].str.contains("Maze Runner")
df_mr_movies = rt_movies[mr_movies].sort_values("original_release_date")

df_mr_movies = df_mr_movies.reset_index()
del df_mr_movies['index']

df_mr_movies[["movie_title", "tomatometer_rating"]]

"""### Data Charts and Plots (Rotten Tomato)

Plotting out Each Aformentioned Movie's Rotten Tomoto-Meter Rating

Note: Movies are plotted by index in order of release date (ex: The Godather = 0, The Godfather II = 1, ...etc)
"""

# Plotting out The Maze Runner ("mr") Movie ratings by movie 
df_mr_movies["tomatometer_rating"].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_mr_movies["tomatometer_rating"].index)

# Plotting out Men in Black ("mib") Movie ratings by movie
df_ws_mib["tomatometer_rating"].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_ws_mib["tomatometer_rating"].index)

# Plotting out The Matrix ("tm") Movie ratings by movie
df_lw_tm["tomatometer_rating"].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_lw_tm["tomatometer_rating"].index)

# Plotting out Lord of the Rings ("lotr") Movie ratings by movie
df_ew_lotr["tomatometer_rating"].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_ew_lotr["tomatometer_rating"].index)

# Plotting out The Godfather ("tg") Movie ratings by movie
df_ap_tg['tomatometer_rating'].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_ap_tg['tomatometer_rating'].index)

# Plotting out Back to the Future ("bttf") Movie ratings by movie
df_bttf_movies["tomatometer_rating"].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_bttf_movies["tomatometer_rating"].index)

# Plotting out Spider-Man ("sm") Movie ratings by movie
df_tm_sm['tomatometer_rating'].plot(    
    xlabel = "Movie",
    ylabel = "Rating",
    xticks = df_tm_sm['tomatometer_rating'].index)

"""Compiling each movie's Rotten Tomato-Meter Score into its own dataframe, with the columns being each movie, and the row being the average rating per index of movie (i.e. number of movie in the series - first, second, third)

*Note*: The Rotten Tomato dataframe ("rt_movies") compiled each movie by index, and hence when we filtered above, all the indexs were different as opposed to the IMDB dataframe, where all our indexs were 0,1, and 2. Hence, we had to reset the index to make all the movies be index 0, 1, and 2 to compile the table [dataframe] below
"""

df_rt_movies = pd.DataFrame(data = { 'Maze Runner': df_mr_movies["tomatometer_rating"], 
                     'Men In Black': df_ws_mib["tomatometer_rating"],
                     'The Matrix': df_lw_tm["tomatometer_rating"],
                     'Lord Of The Rings': df_ew_lotr["tomatometer_rating"],
                     'The Godfather': df_ap_tg['tomatometer_rating'],
                     'Back To The Future': df_bttf_movies["tomatometer_rating"],
                     'Spider-Man': df_tm_sm['tomatometer_rating']

                     })

"""Calculating / Aggregating the Average Rotten Tomato-Meter Score of All the movies by Index - the average score of all the first movies, the second movies, and the third movies of each Movie Series

Plotting out the results
"""

rt_mean_per_index = df_rt_movies.mean(axis=1)
mean_per_index.plot(
    xlabel = "Movie Order",
    ylabel = "AVG Tomato Meter Rating",
    xticks = rt_mean_per_index.index
)